{"version":3,"file":"oxi.umd.js","sources":["../src/make-mutation-observer.ts","../src/wait-for-element.ts"],"sourcesContent":["\r\n/**\r\n * Configuration used for {@link makeMutationObserver} and {@link MutationObserver}.\r\n */\r\nexport interface MakeMutationObserverInit extends MutationObserverInit {\r\n    /**\r\n     * Target node for mutation observer. This will be used for `MutationObserver.observe`.\r\n     */\r\n    target: Node;\r\n    /**\r\n     * Abort signal used for disconnecting mutation observer.\r\n     * \r\n     * If abort signal is aborted, then mutation observer is disconnected.\r\n     */\r\n    abortSignal?: AbortSignal;\r\n    /**\r\n     * This will make mutation observer disconnect after detecting mutation once.\r\n     */\r\n    once?: boolean;\r\n}\r\n\r\nexport type MakeMutationObserverCallback = (info: { records: MutationRecord[], observer: MutationObserver }) => void;\r\n\r\n/**\r\n* Create a new `MutationObserver` with options and callback.\r\n* @param {MakeMutationObserverInit} options \r\n* @param {MakeMutationObserverCallback} callback \r\n* @returns {MutationObserver}\r\n*/\r\nexport function makeMutationObserver({ target, abortSignal, once, ...options }: MakeMutationObserverInit, callback: MakeMutationObserverCallback): MutationObserver {\r\n   const observer = new MutationObserver(records => {\r\n        if (once) observer.disconnect();\r\n        callback({ records, observer });\r\n   });\r\n\r\n   observer.observe(target, options);\r\n\r\n   abortSignal?.addEventListener(\"abort\", () => {\r\n       observer.disconnect();\r\n   });\r\n\r\n   return observer;\r\n}","\r\nimport { makeMutationObserver } from \"./make-mutation-observer\";\r\n\r\n/**\r\n * Interface for options used in {@link waitForElementByOptions}, used for configuring how its operation works.\r\n */\r\nexport interface WaitForElementOptions {\r\n    /** \r\n     * If set to true, it will select element by ID, and it will use the {@link document.documentElement} as the parent selector. {@link WaitForElementOptions.parent} will not apply.\r\n     * \r\n     * This option will precede any other options, such as {@link WaitForElementOptions.multiple} option and the {@link WaitForElementOptions.selector} option, meaning the operation will always select element by the ID specified by {@link WaitForElementOptions.id} option, even if {@link WaitForElementOptions.multiple} or {@link WaitForElementOptions.selector} option is set.\r\n     */\r\n    id?: string;\r\n    /** \r\n     * The selector for the element.\r\n     * \r\n     * If set to `string[]`, then it will query select single element for each selector in the array, returning array of element.\r\n     * \r\n     * If {@link WaitForElementOptions.multiple} option is set to true, then it will query select all element for each selector in array, and then combines them into one, returning array of element.\r\n     * @see {@link WaitForElementOptions.parent} for limiting the scope of query selector\r\n     * @see {@link WaitForElementOptions.id} for getting element only by ID\r\n     */\r\n    selector?: string | string[];\r\n    /** \r\n     * If {@link ParentNode} is passed, it will use the {@link WaitForElementOptions.parent} element as the parent selector.\r\n     * \r\n     * This option will limit the scope of the query selector from the {@link WaitForElementOptions.parent} element. This may be useful for optimizing performance.\r\n     */\r\n    parent?: ParentNode;\r\n    /**\r\n     * If set with {@link AbortSignal} instance, user will able to abort this operation by using {@link AbortSignal.abort}.\r\n     */\r\n    abortSignal?: AbortSignal;\r\n    /**\r\n     * If set to true, this operation will query select multiple element by using {@link ParentNode.querySelectorAll} instead of {@link ParentNode.querySelector}.\r\n     */\r\n    multiple?: boolean;\r\n    /**\r\n     * Enable timeout for waiting operation.\r\n     * \r\n     * If waiting operation reaches timeout, it will throw {@link WaitForElementTimeoutError} or return null, depending on {@link WaitForElementOptions.throwError} option.\r\n     * \r\n     * The timeout is set by {@link WaitForElementOptions.timeout} option. The timeout is set in millisecond.\r\n     */\r\n    enableTimeout?: boolean;\r\n    /**\r\n     * Set the timeout in millisecond. Default timeout is 5 seconds.\r\n     * \r\n     * This option will do nothing if {@link WaitForElementOptions.enableTimeout} is set to false.\r\n     * @see {@link WaitForElementOptions.enableTimeout}\r\n     */\r\n    timeout?: number;\r\n    /**\r\n     * Set how many attempt this operation can query select the target element.\r\n     * \r\n     * If it reaches max attempt, it will throw {@link WaitForElementMaximumTriesError} or return null, depending on {@link WaitForElementOptions.throwError} option.\r\n     */\r\n    maxTries?: number;\r\n    /**\r\n     * Ensure DOM content loaded by listening to `DOMContentLoad` event, or checking {@link document.readyState} before running this operation.\r\n     */\r\n    ensureDomContentLoaded?: boolean;\r\n    /** \r\n     * Set options for {@link MutationObserver} used in this operation.\r\n     */\r\n    observerOptions?: MutationObserverInit;\r\n    /**\r\n     * Filter the target element(s) before being returned.\r\n     */\r\n    filter?: (elem: Element | null) => boolean;\r\n    /** \r\n     * Transform the target element(s) before being returned.\r\n     */\r\n    transform?: (elem: Element | null) => Element;\r\n}\r\n\r\nexport type WaitForElementReturnType = HTMLElement | HTMLElement[] | null;\r\n\r\n/**\r\n * Wait and get element that is not yet available in DOM by using element's ID asyncronously. It will use {@link document.getElementById} internally for getting the element.\r\n * \r\n * This is a simple wrapper around {@link waitForElementByOptions}.\r\n * @param id specify element's ID value\r\n * @param options specify additional options for {@link waitForElementByOptions}\r\n * @returns element with specified ID or null if element not found or something went wrong\r\n * @see {@link WaitForElementOptions}\r\n * @see {@link waitForElementByOptions}\r\n */\r\nexport function waitForElementById(id: string): Promise<Element | null> {\r\n    return waitForElementByOptions({ id })\r\n}\r\n\r\n/**\r\n * Wait for element that is not available yet in the DOM asyncronously, then return that element.\r\n * \r\n * Instead of query selecting element through {@link document.documentElement}, it will instead use the parent element specified by the `parent` parameter as the scope for query selection.\r\n * \r\n * This may help optimize performance, searching element through specific scope of another element instead of the entire document.\r\n * \r\n * This is a simple wrapper around {@link waitForElementByOptions}.\r\n * @param parent specify scope for target element query selection by parent element\r\n * @param selector specify selector for the target element\r\n * @param options specify additional options for {@link waitForElementByOptions}\r\n * @returns return multiple elements in {@link Array}, a single element or null depending on the parameters\r\n * @see {@link WaitForElementOptions}\r\n * @see {@link waitForElementByOptions}\r\n */\r\nexport function waitForElementByParent<S extends keyof HTMLElementTagNameMap>(parent: ParentNode, selector: S, options?: WaitForElementOptions & { multiple: false }): Promise<HTMLElementTagNameMap[S] | null>;\r\nexport function waitForElementByParent(parent: ParentNode, selector: string, options?: WaitForElementOptions & ({ multiple: false } | { id: string })): Promise<HTMLElement | null>;\r\nexport function waitForElementByParent(parent: ParentNode, selector: string, options?: WaitForElementOptions & { multiple: true }): Promise<HTMLElement[] | null>;\r\nexport function waitForElementByParent(parent: ParentNode, selector: string[], options?: WaitForElementOptions): Promise<HTMLElement[] | null>;\r\nexport function waitForElementByParent(parent: any, selector: any, options: any = {}): any {\r\n    return waitForElementByOptions({ selector, parent, ...options });\r\n}\r\n\r\n/**\r\n * Wait for element that is not available yet in the DOM asyncronously, then return that element.\r\n * \r\n * This is a simple wrapper around {@link waitForElementByOptions}.\r\n * @param selector specify selector for the target element\r\n * @param options specify additional options for {@link waitForElementByOptions}\r\n * @returns return multiple elements in {@link Array}, a single element or null depending on the parameters\r\n * @see {@link WaitForElementOptions}\r\n * @see {@link waitForElementByOptions}\r\n */\r\nexport function waitForElement<S extends keyof HTMLElementTagNameMap>(selector: S, options?: WaitForElementOptions & { multiple: false }): HTMLElementTagNameMap[S] | null;\r\nexport function waitForElement(selector: string, options?: WaitForElementOptions & ({ multiple: false } | { id: string })): Promise<Element | null>;\r\nexport function waitForElement(selector: string, options?: WaitForElementOptions & { multiple: true }): Promise<Element[] | null>;\r\nexport function waitForElement(selector: string[], options?: WaitForElementOptions): Promise<Element[] | null>;\r\nexport function waitForElement(selector: any, options: any = {}): any {\r\n    return waitForElementByOptions({ selector, ...options });\r\n}\r\n\r\n/**\r\n * Wait for element that is not available yet in the DOM asyncronously, then return that element.\r\n * \r\n * This operation works by listening for DOM (or an parent element specified by {@link WaitForElementOptions.parent}) subtree changes using {@link MutationObserver}, then execute element selection each time changes happen.\r\n * \r\n * If an element not found, then it will attempt to retry the same operation again. This can be controlled by using {@link WaitForElementOptions.maxTries}, {@link WaitForElementOptions.timeout}, and etc.\r\n * \r\n * Behavior described here may not be accurate if options are specifically configured.\r\n * \r\n * @param options configure how the operation works by specifying options\r\n * @returns depending on the options, it may return multiple elements in {@link Array}, a single element, or null if element not found or something went wrong\r\n * @see {@link WaitForElementOptions}\r\n * @see {@link waitForElement}\r\n */\r\nexport function waitForElementByOptions<S extends keyof HTMLElementTagNameMap>(options: WaitForElementOptions & { selector: S; multiple: false }): Promise<HTMLElementTagNameMap[S] | null>;\r\nexport function waitForElementByOptions(options: WaitForElementOptions & ({ multiple: false } | { id: string })): Promise<Element | null>;\r\nexport function waitForElementByOptions(options: WaitForElementOptions & { multiple: true }): Promise<Element[] | null>;\r\nexport function waitForElementByOptions(options: WaitForElementOptions & { selector: string[] }): Promise<Element[] | null>;\r\nexport function waitForElementByOptions(\r\n    { id,\r\n        selector,\r\n        parent = document.documentElement,\r\n        abortSignal,\r\n        multiple = false,\r\n        timeout = 5000,\r\n        enableTimeout = true,\r\n        maxTries = Number.MAX_SAFE_INTEGER,\r\n        ensureDomContentLoaded = true,\r\n        observerOptions = {},\r\n        filter,\r\n        transform }: WaitForElementOptions = {}) {\r\n    return new Promise((resolve, reject) => {\r\n        let result: Element | Element[] | null,\r\n            tries = 0;\r\n\r\n        if (ensureDomContentLoaded && document.readyState == \"loading\") {\r\n            document.addEventListener(\"DOMContentLoaded\", () => {\r\n                initQueryElement();\r\n            });\r\n        }\r\n        else {\r\n            initQueryElement();\r\n        }\r\n\r\n        function initQueryElement() {\r\n            const firstResult = processQueryElement();\r\n\r\n            if (firstResult) return;\r\n            \r\n            let observer = makeMutationObserver(\r\n                { target: parent,\r\n                    childList: true,\r\n                    subtree: true,\r\n                    abortSignal,\r\n                    ...observerOptions },\r\n                () => processQueryElement(observer));\r\n    \r\n            let timeoutId = -1;\r\n    \r\n            if (enableTimeout) {\r\n                timeoutId = window.setTimeout(() => {\r\n                    observer.disconnect();\r\n                    resolve(null);\r\n                }, timeout);\r\n            }\r\n    \r\n            abortSignal?.addEventListener(\"abort\", () => {\r\n                clearTimeout(timeoutId);\r\n                observer.disconnect();\r\n                resolve(null);\r\n            });\r\n    \r\n            processQueryElement();\r\n        }\r\n\r\n        function processQueryElement(observer?: MutationObserver) {\r\n            abortSignal?.throwIfAborted();\r\n\r\n            if (multiple && selector != undefined && id == undefined) {\r\n                if (Array.isArray(selector)) {\r\n                    result = [];\r\n                    for (const sel of selector) {\r\n                        result = result.concat(Array.from(parent.querySelectorAll(sel)));\r\n                    }\r\n                }\r\n                else {\r\n                    result = Array.from(applyFilterTransform(parent.querySelectorAll(selector)));\r\n                }\r\n            }\r\n            else {\r\n                if (id) {\r\n                    result = document.getElementById(id);\r\n                }\r\n                else if (Array.isArray(selector)) {\r\n                    result = [];\r\n\r\n                    result = Array.from(applyFilterTransform(parent.querySelectorAll(selector.join(\", \"))));\r\n                }\r\n                else if (typeof selector == \"string\") {\r\n                    result = parent.querySelector(selector);\r\n\r\n                    if (transform) result = transform(result);\r\n                    if (filter != undefined && !filter(result)) {\r\n                        return null;\r\n                    }\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n\r\n            function* applyFilterTransform(elements: Iterable<Element>) {\r\n                for (let elem of elements) {\r\n                    if (filter != null && filter(elem)) {\r\n                        if (transform) elem = transform(elem);\r\n                        yield elem;\r\n                    }\r\n                    else if (filter == null && transform) {\r\n                        yield transform(elem);\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n            if (multiple && Array.isArray(result) ? result.length > 0 : result) {\r\n                observer?.disconnect();\r\n                resolve(result);\r\n                return result;\r\n            }\r\n\r\n            tries++;\r\n\r\n            if (tries >= maxTries) {\r\n                observer?.disconnect();                \r\n                resolve(null);\r\n                return null;\r\n            }\r\n        }\r\n    });\r\n}"],"names":["makeMutationObserver","target","abortSignal","once","options","callback","observer","records","waitForElementById","id","waitForElementByOptions","waitForElementByParent","parent","selector","waitForElement","multiple","timeout","enableTimeout","maxTries","ensureDomContentLoaded","observerOptions","filter","transform","resolve","reject","result","tries","initQueryElement","processQueryElement","timeoutId","sel","applyFilterTransform","elements","elem"],"mappings":"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"}