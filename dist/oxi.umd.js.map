{"version":3,"file":"oxi.umd.js","sources":["../src/make-mutation-observer.ts","../src/wait-for-element.ts"],"sourcesContent":["\n/**\n * Configuration used for {@link makeMutationObserver} and {@link MutationObserver}.\n */\nexport interface MakeMutationObserverInit extends MutationObserverInit {\n    /**\n     * Target node for mutation observer. This will be used for `MutationObserver.observe`.\n     */\n    target: Node;\n    /**\n     * Abort signal used for disconnecting mutation observer.\n     * \n     * If abort signal is aborted, then mutation observer is disconnected.\n     */\n    abortSignal?: AbortSignal;\n    /**\n     * This will make mutation observer disconnect after detecting mutation once.\n     */\n    once?: boolean;\n}\n\nexport type MakeMutationObserverCallback = (info: { records: MutationRecord[], observer: MutationObserver }) => void;\n\n/**\n* Create a new `MutationObserver` with options and callback.\n* @param {MakeMutationObserverInit} options \n* @param {MakeMutationObserverCallback} callback \n* @returns {MutationObserver}\n*/\nexport function makeMutationObserver({ target, abortSignal, once, ...options }: MakeMutationObserverInit, callback: MakeMutationObserverCallback): MutationObserver {\n   const observer = new MutationObserver(records => {\n        if (once) observer.disconnect();\n        callback({ records, observer });\n   });\n\n   observer.observe(target, options);\n\n   abortSignal?.addEventListener(\"abort\", () => {\n       observer.disconnect();\n   });\n\n   return observer;\n}","\nimport { makeMutationObserver } from \"./make-mutation-observer\";\n\n/**\n * Interface for options used in {@link waitForElementByOptions}, used for configuring how its operation works.\n */\nexport interface WaitForElementOptions {\n    /** \n     * If set to true, it will select element by ID, and it will use the {@link document.documentElement} as the parent selector. {@link WaitForElementOptions.parent} will not apply.\n     * \n     * This option will precede any other options, such as {@link WaitForElementOptions.multiple} option and the {@link WaitForElementOptions.selector} option, meaning the operation will always select element by the ID specified by {@link WaitForElementOptions.id} option, even if {@link WaitForElementOptions.multiple} or {@link WaitForElementOptions.selector} option is set.\n     */\n    id?: string;\n    /** \n     * The selector for the element.\n     * \n     * If set to `string[]`, then it will query select single element for each selector in the array, returning array of element.\n     * \n     * If {@link WaitForElementOptions.multiple} option is set to true, then it will query select all element for each selector in array, and then combines them into one, returning array of element.\n     * @see {@link WaitForElementOptions.parent} for limiting the scope of query selector\n     * @see {@link WaitForElementOptions.id} for getting element only by ID\n     */\n    selector?: string | string[];\n    /** \n     * If {@link ParentNode} is passed, it will use the {@link WaitForElementOptions.parent} element as the parent selector.\n     * \n     * This option will limit the scope of the query selector from the {@link WaitForElementOptions.parent} element. This may be useful for optimizing performance.\n     */\n    parent?: ParentNode;\n    /**\n     * If set with {@link AbortSignal} instance, user will able to abort this operation by using {@link AbortSignal.abort}.\n     */\n    abortSignal?: AbortSignal;\n    /**\n     * If set to true, this operation will query select multiple element by using {@link ParentNode.querySelectorAll} instead of {@link ParentNode.querySelector}.\n     */\n    multiple?: boolean;\n    /**\n     * Enable timeout for waiting operation.\n     * \n     * If waiting operation reaches timeout, it will throw {@link WaitForElementTimeoutError} or return null, depending on {@link WaitForElementOptions.throwError} option.\n     * \n     * The timeout is set by {@link WaitForElementOptions.timeout} option. The timeout is set in millisecond.\n     */\n    enableTimeout?: boolean;\n    /**\n     * Set the timeout in millisecond. Default timeout is 5 seconds.\n     * \n     * This option will do nothing if {@link WaitForElementOptions.enableTimeout} is set to false.\n     * @see {@link WaitForElementOptions.enableTimeout}\n     */\n    timeout?: number;\n    /**\n     * Set how many attempt this operation can query select the target element.\n     * \n     * If it reaches max attempt, it will throw {@link WaitForElementMaximumTriesError} or return null, depending on {@link WaitForElementOptions.throwError} option.\n     */\n    maxTries?: number;\n    /**\n     * Ensure DOM content loaded by listening to `DOMContentLoad` event, or checking {@link document.readyState} before running this operation.\n     */\n    ensureDomContentLoaded?: boolean;\n    /** \n     * Set options for {@link MutationObserver} used in this operation.\n     */\n    observerOptions?: MutationObserverInit;\n    /**\n     * Filter the target element(s) before being returned.\n     */\n    filter?: (elem: Element | null) => boolean;\n    /** \n     * Transform the target element(s) before being returned.\n     */\n    transform?: (elem: Element | null) => Element;\n}\n\nexport type WaitForElementReturnType = HTMLElement | HTMLElement[] | null;\n\ntype SingleElementOptions = WaitForElementOptions & ({ multiple: false } | { id: string });\ntype ArrayElementOptions = WaitForElementOptions & { multiple: true };\ntype SingleElementTagNameOptions<T extends keyof HTMLElementTagNameMap> = WaitForElementOptions & { selector: T; multiple: false };\n\n/**\n * Wait and get element that is not yet available in DOM by using element's ID asyncronously. It will use {@link document.getElementById} internally for getting the element.\n * \n * This is a simple wrapper around {@link waitForElementByOptions}.\n * @param id specify element's ID value\n * @param options specify additional options for {@link waitForElementByOptions}\n * @returns element with specified ID or null if element not found or something went wrong\n * @see {@link WaitForElementOptions}\n * @see {@link waitForElementByOptions}\n */\nexport function waitForElementById<E extends Element>(id: string): Promise<E | null> {\n    return waitForElementByOptions({ id })\n}\n\n/**\n * Wait for element that is not available yet in the DOM asyncronously, then return that element.\n * \n * Instead of query selecting element through {@link document.documentElement}, it will instead use the parent element specified by the `parent` parameter as the scope for query selection.\n * \n * This may help optimize performance, searching element through specific scope of another element instead of the entire document.\n * \n * This is a simple wrapper around {@link waitForElementByOptions}.\n * @param parent specify scope for target element query selection by parent element\n * @param selector specify selector for the target element\n * @param options specify additional options for {@link waitForElementByOptions}\n * @returns return multiple elements in {@link Array}, a single element or null depending on the parameters\n * @see {@link WaitForElementOptions}\n * @see {@link waitForElementByOptions}\n */\nexport function waitForElementByParent<T extends keyof HTMLElementTagNameMap>(parent: ParentNode, selector: T, options?: SingleElementTagNameOptions<T>): Promise<HTMLElementTagNameMap[T] | null>;\nexport function waitForElementByParent<E extends Element>(parent: ParentNode, selector: string, options?: SingleElementOptions): Promise<E | null>;\nexport function waitForElementByParent<E extends Element>(parent: ParentNode, selector: string, options?: ArrayElementOptions): Promise<E[] | null>;\nexport function waitForElementByParent<E extends Element>(parent: ParentNode, selector: string, options?: WaitForElementOptions): Promise<E | null>;\nexport function waitForElementByParent<E extends Element>(parent: ParentNode, selector: string[], options?: WaitForElementOptions): Promise<E[] | null>;\nexport function waitForElementByParent(parent: any, selector: any, options: any = {}): any {\n    return waitForElementByOptions({ selector, parent, ...options });\n}\n\n/**\n * Wait for element that is not available yet in the DOM asyncronously, then return that element.\n * \n * This is a simple wrapper around {@link waitForElementByOptions}.\n * @param selector specify selector for the target element\n * @param options specify additional options for {@link waitForElementByOptions}\n * @returns return multiple elements in {@link Array}, a single element or null depending on the parameters\n * @see {@link WaitForElementOptions}\n * @see {@link waitForElementByOptions}\n */\nexport function waitForElement<T extends keyof HTMLElementTagNameMap>(selector: T, options?: SingleElementTagNameOptions<T>): Promise<HTMLElementTagNameMap[T] | null>;\nexport function waitForElement<E extends Element>(selector: string, options?: SingleElementOptions): Promise<E | null>;\nexport function waitForElement<E extends Element>(selector: string, options?: ArrayElementOptions): Promise<E[] | null>;\nexport function waitForElement<E extends Element>(selector: string, options?: WaitForElementOptions): Promise<E | null>;\nexport function waitForElement<E extends Element>(selector: string[], options?: WaitForElementOptions): Promise<E[] | null>;\nexport function waitForElement(selector: any, options: any = {}): any {\n    return waitForElementByOptions({ selector, ...options });\n}\n\n/**\n * Wait for element that is not available yet in the DOM asyncronously, then return that element.\n * \n * This operation works by listening for DOM (or an parent element specified by {@link WaitForElementOptions.parent}) subtree changes using {@link MutationObserver}, then execute element selection each time changes happen.\n * \n * If an element not found, then it will attempt to retry the same operation again. This can be controlled by using {@link WaitForElementOptions.maxTries}, {@link WaitForElementOptions.timeout}, and etc.\n * \n * Behavior described here may not be accurate if options are specifically configured.\n * \n * @param options configure how the operation works by specifying options\n * @returns depending on the options, it may return multiple elements in {@link Array}, a single element, or null if element not found or something went wrong\n * @see {@link WaitForElementOptions}\n * @see {@link waitForElement}\n */\nexport function waitForElementByOptions<T extends keyof HTMLElementTagNameMap>(options: SingleElementTagNameOptions<T>): Promise<HTMLElementTagNameMap[T] | null>;\nexport function waitForElementByOptions<E extends Element>(options: SingleElementOptions): Promise<E | null>;\nexport function waitForElementByOptions<E extends Element>(options: ArrayElementOptions): Promise<E[] | null>;\nexport function waitForElementByOptions<E extends Element>(options: WaitForElementOptions & { selector: string }): Promise<E | null>;\nexport function waitForElementByOptions<E extends Element>(options: WaitForElementOptions & { selector: string[] }): Promise<E[] | null>;\nexport function waitForElementByOptions(\n    { id,\n        selector,\n        parent = document.documentElement,\n        abortSignal,\n        multiple = false,\n        timeout = 5000,\n        enableTimeout = true,\n        maxTries = Number.MAX_SAFE_INTEGER,\n        ensureDomContentLoaded = true,\n        observerOptions = {},\n        filter,\n        transform }: WaitForElementOptions = {}) {\n    return new Promise((resolve, reject) => {\n        let result: Element | Element[] | null,\n            tries = 0;\n\n        if (ensureDomContentLoaded && document.readyState == \"loading\") {\n            document.addEventListener(\"DOMContentLoaded\", () => {\n                initQueryElement();\n            });\n        }\n        else {\n            initQueryElement();\n        }\n\n        function initQueryElement() {\n            const firstResult = processQueryElement();\n\n            if (firstResult) return;\n            \n            let observer = makeMutationObserver(\n                { target: parent,\n                    childList: true,\n                    subtree: true,\n                    abortSignal,\n                    ...observerOptions },\n                () => processQueryElement(observer));\n    \n            let timeoutId = -1;\n    \n            if (enableTimeout) {\n                timeoutId = window.setTimeout(() => {\n                    observer.disconnect();\n                    resolve(null);\n                }, timeout);\n            }\n    \n            abortSignal?.addEventListener(\"abort\", () => {\n                clearTimeout(timeoutId);\n                observer.disconnect();\n                resolve(null);\n            });\n    \n            processQueryElement();\n        }\n\n        function processQueryElement(observer?: MutationObserver) {\n            abortSignal?.throwIfAborted();\n\n            if (multiple && selector != undefined && id == undefined) {\n                if (Array.isArray(selector)) {\n                    result = [];\n                    for (const sel of selector) {\n                        result = result.concat(Array.from(parent.querySelectorAll(sel)));\n                    }\n                }\n                else {\n                    result = Array.from(applyFilterTransform(parent.querySelectorAll(selector)));\n                }\n            }\n            else {\n                if (id) {\n                    result = document.getElementById(id);\n                }\n                else if (Array.isArray(selector)) {\n                    result = [];\n\n                    result = Array.from(applyFilterTransform(parent.querySelectorAll(selector.join(\", \"))));\n                }\n                else if (typeof selector == \"string\") {\n                    result = parent.querySelector(selector);\n\n                    if (transform) result = transform(result);\n                    if (filter != undefined && !filter(result)) {\n                        return null;\n                    }\n                }\n                else {\n                    return null;\n                }\n            }\n\n            function* applyFilterTransform(elements: Iterable<Element>) {\n                for (let elem of elements) {\n                    if (filter != null && filter(elem)) {\n                        if (transform) elem = transform(elem);\n                        yield elem;\n                    }\n                    else if (filter == null && transform) {\n                        yield transform(elem);\n                    }\n                }\n            }\n\n\n            if (multiple && Array.isArray(result) ? result.length > 0 : result) {\n                observer?.disconnect();\n                resolve(result);\n                return result;\n            }\n\n            tries++;\n\n            if (tries >= maxTries) {\n                observer?.disconnect();                \n                resolve(null);\n                return null;\n            }\n        }\n    });\n}"],"names":["makeMutationObserver","target","abortSignal","once","options","callback","observer","records","waitForElementById","id","waitForElementByOptions","waitForElementByParent","parent","selector","waitForElement","multiple","timeout","enableTimeout","maxTries","ensureDomContentLoaded","observerOptions","filter","transform","resolve","reject","result","tries","initQueryElement","processQueryElement","timeoutId","sel","applyFilterTransform","elements","elem"],"mappings":"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"}