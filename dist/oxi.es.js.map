{"version":3,"file":"oxi.es.js","sources":["../src/make-mutation-observer.ts","../src/wait-for-element.ts"],"sourcesContent":["\n/**\n * Configuration used for {@link makeMutationObserver} and {@link MutationObserver}.\n */\nexport interface MakeMutationObserverInit extends MutationObserverInit {\n    /**\n     * Target node for mutation observer. This will be used for `MutationObserver.observe`.\n     */\n    target: Node;\n    /**\n     * Abort signal used for disconnecting mutation observer.\n     * \n     * If abort signal is aborted, then mutation observer is disconnected.\n     */\n    abortSignal?: AbortSignal;\n    /**\n     * This will make mutation observer disconnect after detecting mutation once.\n     */\n    once?: boolean;\n}\n\nexport type MakeMutationObserverCallback = (info: { records: MutationRecord[], observer: MutationObserver }) => void;\n\n/**\n* Create a new `MutationObserver` with options and callback.\n* @param {MakeMutationObserverInit} options \n* @param {MakeMutationObserverCallback} callback \n* @returns {MutationObserver}\n*/\nexport function makeMutationObserver({ target, abortSignal, once, ...options }: MakeMutationObserverInit, callback: MakeMutationObserverCallback): MutationObserver {\n   const observer = new MutationObserver(records => {\n        if (once) observer.disconnect();\n        callback({ records, observer });\n   });\n\n   observer.observe(target, options);\n\n   abortSignal?.addEventListener(\"abort\", () => {\n       observer.disconnect();\n   });\n\n   return observer;\n}","\nimport { makeMutationObserver } from \"./make-mutation-observer\";\n\n/**\n * Interface for options used in {@link waitForElementByOptions}, used for configuring how its operation works.\n */\nexport interface WaitForElementOptions {\n    /** \n     * If set to true, it will select element by ID, and it will use the {@link document.documentElement} as the parent selector. {@link WaitForElementOptions.parent} will not apply.\n     * \n     * This option will precede any other options, such as {@link WaitForElementOptions.multiple} option and the {@link WaitForElementOptions.selector} option, meaning the operation will always select element by the ID specified by {@link WaitForElementOptions.id} option, even if {@link WaitForElementOptions.multiple} or {@link WaitForElementOptions.selector} option is set.\n     */\n    id?: string;\n    /** \n     * The selector for the element.\n     * \n     * If set to `string[]`, then it will query select single element for each selector in the array, returning array of element.\n     * \n     * If {@link WaitForElementOptions.multiple} option is set to true, then it will query select all element for each selector in array, and then combines them into one, returning array of element.\n     * @see {@link WaitForElementOptions.parent} for limiting the scope of query selector\n     * @see {@link WaitForElementOptions.id} for getting element only by ID\n     */\n    selector?: string | string[];\n    /** \n     * If {@link ParentNode} is passed, it will use the {@link WaitForElementOptions.parent} element as the parent selector.\n     * \n     * This option will limit the scope of the query selector from the {@link WaitForElementOptions.parent} element. This may be useful for optimizing performance.\n     */\n    parent?: ParentNode;\n    /**\n     * If set with {@link AbortSignal} instance, user will able to abort this operation by using {@link AbortSignal.abort}.\n     */\n    abortSignal?: AbortSignal;\n    /**\n     * If set to true, this operation will query select multiple element by using {@link ParentNode.querySelectorAll} instead of {@link ParentNode.querySelector}.\n     */\n    multiple?: boolean;\n    /**\n     * Enable timeout for waiting operation.\n     * \n     * If waiting operation reaches timeout, it will throw {@link WaitForElementTimeoutError} or return null, depending on {@link WaitForElementOptions.throwError} option.\n     * \n     * The timeout is set by {@link WaitForElementOptions.timeout} option. The timeout is set in millisecond.\n     */\n    enableTimeout?: boolean;\n    /**\n     * Set the timeout in millisecond. Default timeout is 5 seconds.\n     * \n     * This option will do nothing if {@link WaitForElementOptions.enableTimeout} is set to false.\n     * @see {@link WaitForElementOptions.enableTimeout}\n     */\n    timeout?: number;\n    /**\n     * Set how many attempt this operation can query select the target element.\n     * \n     * If it reaches max attempt, it will throw {@link WaitForElementMaximumTriesError} or return null, depending on {@link WaitForElementOptions.throwError} option.\n     */\n    maxTries?: number;\n    /**\n     * Ensure DOM content loaded by listening to `DOMContentLoad` event, or checking {@link document.readyState} before running this operation.\n     */\n    ensureDomContentLoaded?: boolean;\n    /** \n     * Set options for {@link MutationObserver} used in this operation.\n     */\n    observerOptions?: MutationObserverInit;\n    /**\n     * Filter the target element(s) before being returned.\n     */\n    filter?: (elem: Element | null) => boolean;\n    /** \n     * Transform the target element(s) before being returned.\n     */\n    transform?: (elem: Element | null) => Element;\n}\n\nexport type WaitForElementReturnType = HTMLElement | HTMLElement[] | null;\n\n/**\n * Wait and get element that is not yet available in DOM by using element's ID asyncronously. It will use {@link document.getElementById} internally for getting the element.\n * \n * This is a simple wrapper around {@link waitForElementByOptions}.\n * @param id specify element's ID value\n * @param options specify additional options for {@link waitForElementByOptions}\n * @returns element with specified ID or null if element not found or something went wrong\n * @see {@link WaitForElementOptions}\n * @see {@link waitForElementByOptions}\n */\nexport function waitForElementById<E extends Element>(id: string): Promise<E | null> {\n    return waitForElementByOptions({ id })\n}\n\n/**\n * Wait for element that is not available yet in the DOM asyncronously, then return that element.\n * \n * Instead of query selecting element through {@link document.documentElement}, it will instead use the parent element specified by the `parent` parameter as the scope for query selection.\n * \n * This may help optimize performance, searching element through specific scope of another element instead of the entire document.\n * \n * This is a simple wrapper around {@link waitForElementByOptions}.\n * @param parent specify scope for target element query selection by parent element\n * @param selector specify selector for the target element\n * @param options specify additional options for {@link waitForElementByOptions}\n * @returns return multiple elements in {@link Array}, a single element or null depending on the parameters\n * @see {@link WaitForElementOptions}\n * @see {@link waitForElementByOptions}\n */\nexport function waitForElementByParent<S extends keyof HTMLElementTagNameMap>(parent: ParentNode, selector: S, options?: WaitForElementOptions & { multiple: false }): Promise<HTMLElementTagNameMap[S] | null>;\nexport function waitForElementByParent<E extends Element>(parent: ParentNode, selector: string, options?: WaitForElementOptions & ({ multiple: false } | { id: string })): Promise<E | null>;\nexport function waitForElementByParent<E extends Element>(parent: ParentNode, selector: string, options?: WaitForElementOptions & { multiple: true }): Promise<E[] | null>;\nexport function waitForElementByParent<E extends Element>(parent: ParentNode, selector: string[], options?: WaitForElementOptions): Promise<E[] | null>;\nexport function waitForElementByParent(parent: any, selector: any, options: any = {}): any {\n    return waitForElementByOptions({ selector, parent, ...options });\n}\n\n/**\n * Wait for element that is not available yet in the DOM asyncronously, then return that element.\n * \n * This is a simple wrapper around {@link waitForElementByOptions}.\n * @param selector specify selector for the target element\n * @param options specify additional options for {@link waitForElementByOptions}\n * @returns return multiple elements in {@link Array}, a single element or null depending on the parameters\n * @see {@link WaitForElementOptions}\n * @see {@link waitForElementByOptions}\n */\nexport function waitForElement<S extends keyof HTMLElementTagNameMap>(selector: S, options?: WaitForElementOptions & { multiple: false }): HTMLElementTagNameMap[S] | null;\nexport function waitForElement<E extends Element>(selector: string, options?: WaitForElementOptions & ({ multiple: false } | { id: string })): Promise<E | null>;\nexport function waitForElement<E extends Element>(selector: string, options?: WaitForElementOptions & { multiple: true }): Promise<E[] | null>;\nexport function waitForElement<E extends Element>(selector: string[], options?: WaitForElementOptions): Promise<E[] | null>;\nexport function waitForElement(selector: any, options: any = {}): any {\n    return waitForElementByOptions({ selector, ...options });\n}\n\n/**\n * Wait for element that is not available yet in the DOM asyncronously, then return that element.\n * \n * This operation works by listening for DOM (or an parent element specified by {@link WaitForElementOptions.parent}) subtree changes using {@link MutationObserver}, then execute element selection each time changes happen.\n * \n * If an element not found, then it will attempt to retry the same operation again. This can be controlled by using {@link WaitForElementOptions.maxTries}, {@link WaitForElementOptions.timeout}, and etc.\n * \n * Behavior described here may not be accurate if options are specifically configured.\n * \n * @param options configure how the operation works by specifying options\n * @returns depending on the options, it may return multiple elements in {@link Array}, a single element, or null if element not found or something went wrong\n * @see {@link WaitForElementOptions}\n * @see {@link waitForElement}\n */\nexport function waitForElementByOptions<S extends keyof HTMLElementTagNameMap>(options: WaitForElementOptions & { selector: S; multiple: false }): Promise<HTMLElementTagNameMap[S] | null>;\nexport function waitForElementByOptions<E extends Element>(options: WaitForElementOptions & ({ multiple: false } | { id: string })): Promise<E | null>;\nexport function waitForElementByOptions<E extends Element>(options: WaitForElementOptions & { multiple: true }): Promise<E[] | null>;\nexport function waitForElementByOptions<E extends Element>(options: WaitForElementOptions & { selector: string[] }): Promise<E[] | null>;\nexport function waitForElementByOptions(\n    { id,\n        selector,\n        parent = document.documentElement,\n        abortSignal,\n        multiple = false,\n        timeout = 5000,\n        enableTimeout = true,\n        maxTries = Number.MAX_SAFE_INTEGER,\n        ensureDomContentLoaded = true,\n        observerOptions = {},\n        filter,\n        transform }: WaitForElementOptions = {}) {\n    return new Promise((resolve, reject) => {\n        let result: Element | Element[] | null,\n            tries = 0;\n\n        if (ensureDomContentLoaded && document.readyState == \"loading\") {\n            document.addEventListener(\"DOMContentLoaded\", () => {\n                initQueryElement();\n            });\n        }\n        else {\n            initQueryElement();\n        }\n\n        function initQueryElement() {\n            const firstResult = processQueryElement();\n\n            if (firstResult) return;\n            \n            let observer = makeMutationObserver(\n                { target: parent,\n                    childList: true,\n                    subtree: true,\n                    abortSignal,\n                    ...observerOptions },\n                () => processQueryElement(observer));\n    \n            let timeoutId = -1;\n    \n            if (enableTimeout) {\n                timeoutId = window.setTimeout(() => {\n                    observer.disconnect();\n                    resolve(null);\n                }, timeout);\n            }\n    \n            abortSignal?.addEventListener(\"abort\", () => {\n                clearTimeout(timeoutId);\n                observer.disconnect();\n                resolve(null);\n            });\n    \n            processQueryElement();\n        }\n\n        function processQueryElement(observer?: MutationObserver) {\n            abortSignal?.throwIfAborted();\n\n            if (multiple && selector != undefined && id == undefined) {\n                if (Array.isArray(selector)) {\n                    result = [];\n                    for (const sel of selector) {\n                        result = result.concat(Array.from(parent.querySelectorAll(sel)));\n                    }\n                }\n                else {\n                    result = Array.from(applyFilterTransform(parent.querySelectorAll(selector)));\n                }\n            }\n            else {\n                if (id) {\n                    result = document.getElementById(id);\n                }\n                else if (Array.isArray(selector)) {\n                    result = [];\n\n                    result = Array.from(applyFilterTransform(parent.querySelectorAll(selector.join(\", \"))));\n                }\n                else if (typeof selector == \"string\") {\n                    result = parent.querySelector(selector);\n\n                    if (transform) result = transform(result);\n                    if (filter != undefined && !filter(result)) {\n                        return null;\n                    }\n                }\n                else {\n                    return null;\n                }\n            }\n\n            function* applyFilterTransform(elements: Iterable<Element>) {\n                for (let elem of elements) {\n                    if (filter != null && filter(elem)) {\n                        if (transform) elem = transform(elem);\n                        yield elem;\n                    }\n                    else if (filter == null && transform) {\n                        yield transform(elem);\n                    }\n                }\n            }\n\n\n            if (multiple && Array.isArray(result) ? result.length > 0 : result) {\n                observer?.disconnect();\n                resolve(result);\n                return result;\n            }\n\n            tries++;\n\n            if (tries >= maxTries) {\n                observer?.disconnect();                \n                resolve(null);\n                return null;\n            }\n        }\n    });\n}"],"names":["makeMutationObserver","target","abortSignal","once","options","callback","observer","records","waitForElementById","id","waitForElementByOptions","waitForElementByParent","parent","selector","waitForElement","multiple","timeout","enableTimeout","maxTries","ensureDomContentLoaded","observerOptions","filter","transform","resolve","reject","result","tries","initQueryElement","processQueryElement","timeoutId","sel","applyFilterTransform","elements","elem"],"mappings":"AA6BgB,SAAAA,EAAqB,EAAE,QAAAC,GAAQ,aAAAC,GAAa,MAAAC,GAAM,GAAGC,KAAqCC,GAA0D;AAC3J,QAAAC,IAAW,IAAI,iBAAiB,CAAWC,MAAA;AACxC,IAAAJ,KAAMG,EAAS,WAAW,GACrBD,EAAA,EAAE,SAAAE,GAAS,UAAAD,EAAA,CAAU;AAAA,EAAA,CAClC;AAEQ,SAAAA,EAAA,QAAQL,GAAQG,CAAO,GAEnBF,KAAA,QAAAA,EAAA,iBAAiB,SAAS,MAAM;AACzC,IAAAI,EAAS,WAAW;AAAA,EAAA,IAGjBA;AACV;AC8CO,SAASE,EAAsCC,GAA+B;AAC1E,SAAAC,EAAwB,EAAE,IAAAD,EAAA,CAAI;AACzC;AAqBO,SAASE,EAAuBC,GAAaC,GAAeT,IAAe,CAAA,GAAS;AACvF,SAAOM,EAAwB,EAAE,UAAAG,GAAU,QAAAD,GAAQ,GAAGR,EAAS,CAAA;AACnE;AAgBO,SAASU,EAAeD,GAAeT,IAAe,IAAS;AAClE,SAAOM,EAAwB,EAAE,UAAAG,GAAU,GAAGT,EAAS,CAAA;AAC3D;AAoBO,SAASM,EACZ;AAAA,EAAE,IAAAD;AAAA,EACE,UAAAI;AAAA,EACA,QAAAD,IAAS,SAAS;AAAA,EAClB,aAAAV;AAAA,EACA,UAAAa,IAAW;AAAA,EACX,SAAAC,IAAU;AAAA,EACV,eAAAC,IAAgB;AAAA,EAChB,UAAAC,IAAW,OAAO;AAAA,EAClB,wBAAAC,IAAyB;AAAA,EACzB,iBAAAC,IAAkB,CAAC;AAAA,EACnB,QAAAC;AAAA,EACA,WAAAC;AAAU,IAA2B,IAAI;AAC7C,SAAO,IAAI,QAAQ,CAACC,GAASC,MAAW;AACpC,QAAIC,GACAC,IAAQ;AAER,IAAAP,KAA0B,SAAS,cAAc,YACxC,SAAA,iBAAiB,oBAAoB,MAAM;AAC/B,MAAAQ;IAAA,CACpB,IAGgBA;AAGrB,aAASA,IAAmB;AAGpB,UAFgBC;AAEH;AAEjB,UAAItB,IAAWN;AAAA,QACX;AAAA,UAAE,QAAQY;AAAA,UACN,WAAW;AAAA,UACX,SAAS;AAAA,UACT,aAAAV;AAAA,UACA,GAAGkB;AAAA,QAAgB;AAAA,QACvB,MAAMQ,EAAoBtB,CAAQ;AAAA,MAAA,GAElCuB,IAAY;AAEhB,MAAIZ,MACYY,IAAA,OAAO,WAAW,MAAM;AAChC,QAAAvB,EAAS,WAAW,GACpBiB,EAAQ,IAAI;AAAA,SACbP,CAAO,IAGDd,KAAA,QAAAA,EAAA,iBAAiB,SAAS,MAAM;AACzC,qBAAa2B,CAAS,GACtBvB,EAAS,WAAW,GACpBiB,EAAQ,IAAI;AAAA,MAAA,IAGIK;IACxB;AAEA,aAASA,EAAoBtB,GAA6B;AAGtD,UAFAJ,KAAA,QAAAA,EAAa,kBAETa,KAAYF,KAAY,QAAaJ,KAAM;AACvC,YAAA,MAAM,QAAQI,CAAQ,GAAG;AACzB,UAAAY,IAAS,CAAA;AACT,qBAAWK,KAAOjB;AACL,YAAAY,IAAAA,EAAO,OAAO,MAAM,KAAKb,EAAO,iBAAiBkB,CAAG,CAAC,CAAC;AAAA;AAInE,UAAAL,IAAS,MAAM,KAAKM,EAAqBnB,EAAO,iBAAiBC,CAAQ,CAAC,CAAC;AAAA,eAI3EJ;AACS,QAAAgB,IAAA,SAAS,eAAehB,CAAE;AAAA,eAE9B,MAAM,QAAQI,CAAQ;AAC3B,QAAAY,IAAS,CAAA,GAEAA,IAAA,MAAM,KAAKM,EAAqBnB,EAAO,iBAAiBC,EAAS,KAAK,IAAI,CAAC,CAAC,CAAC;AAAA,eAEjF,OAAOA,KAAY;AAIxB,YAHSY,IAAAb,EAAO,cAAcC,CAAQ,GAElCS,MAAWG,IAASH,EAAUG,CAAM,IACpCJ,KAAU,QAAa,CAACA,EAAOI,CAAM;AAC9B,iBAAA;AAAA;AAIJ,eAAA;AAIf,gBAAUM,EAAqBC,GAA6B;AACxD,iBAASC,KAAQD;AACb,UAAIX,KAAU,QAAQA,EAAOY,CAAI,KACzBX,MAAWW,IAAOX,EAAUW,CAAI,IAC9B,MAAAA,KAEDZ,KAAU,QAAQC,MACvB,MAAMA,EAAUW,CAAI;AAAA,MAGhC;AAGI,UAAAlB,KAAY,MAAM,QAAQU,CAAM,IAAIA,EAAO,SAAS,IAAIA;AACxD,eAAAnB,KAAA,QAAAA,EAAU,cACViB,EAAQE,CAAM,GACPA;AAKX,UAFAC,KAEIA,KAASR;AACT,eAAAZ,KAAA,QAAAA,EAAU,cACViB,EAAQ,IAAI,GACL;AAAA,IAEf;AAAA,EAAA,CACH;AACL;"}