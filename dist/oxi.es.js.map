{"version":3,"file":"oxi.es.js","sources":["../src/make-mutation-observer.ts","../src/wait-for-element.ts"],"sourcesContent":["\r\n/**\r\n * Configuration used for {@link makeMutationObserver} and {@link MutationObserver}.\r\n */\r\nexport interface MakeMutationObserverInit extends MutationObserverInit {\r\n    /**\r\n     * Target node for mutation observer. This will be used for `MutationObserver.observe`.\r\n     */\r\n    target: Node;\r\n    /**\r\n     * Abort signal used for disconnecting mutation observer.\r\n     * \r\n     * If abort signal is aborted, then mutation observer is disconnected.\r\n     */\r\n    abortSignal?: AbortSignal;\r\n    /**\r\n     * This will make mutation observer disconnect after detecting mutation once.\r\n     */\r\n    once?: boolean;\r\n}\r\n\r\nexport type MakeMutationObserverCallback = (info: { records: MutationRecord[], observer: MutationObserver }) => void;\r\n\r\n/**\r\n* Create a new `MutationObserver` with options and callback.\r\n* @param {MakeMutationObserverInit} options \r\n* @param {MakeMutationObserverCallback} callback \r\n* @returns {MutationObserver}\r\n*/\r\nexport function makeMutationObserver({ target, abortSignal, once, ...options }: MakeMutationObserverInit, callback: MakeMutationObserverCallback): MutationObserver {\r\n   const observer = new MutationObserver(records => {\r\n        if (once) observer.disconnect();\r\n        callback({ records, observer });\r\n   });\r\n\r\n   observer.observe(target, options);\r\n\r\n   abortSignal?.addEventListener(\"abort\", () => {\r\n       observer.disconnect();\r\n   });\r\n\r\n   return observer;\r\n}","\r\nimport { makeMutationObserver } from \"./make-mutation-observer\";\r\n\r\n/**\r\n * Interface for options used in {@link waitForElementByOptions}, used for configuring how its operation works.\r\n */\r\nexport interface WaitForElementOptions {\r\n    /** \r\n     * If set to true, it will select element by ID, and it will use the {@link document.documentElement} as the parent selector. {@link WaitForElementOptions.parent} will not apply.\r\n     * \r\n     * This option will precede any other options, such as {@link WaitForElementOptions.multiple} option and the {@link WaitForElementOptions.selector} option, meaning the operation will always select element by the ID specified by {@link WaitForElementOptions.id} option, even if {@link WaitForElementOptions.multiple} or {@link WaitForElementOptions.selector} option is set.\r\n     */\r\n    id?: string;\r\n    /** \r\n     * The selector for the element.\r\n     * \r\n     * If set to `string[]`, then it will query select single element for each selector in the array, returning array of element.\r\n     * \r\n     * If {@link WaitForElementOptions.multiple} option is set to true, then it will query select all element for each selector in array, and then combines them into one, returning array of element.\r\n     * @see {@link WaitForElementOptions.parent} for limiting the scope of query selector\r\n     * @see {@link WaitForElementOptions.id} for getting element only by ID\r\n     */\r\n    selector?: string | string[];\r\n    /** \r\n     * If {@link ParentNode} is passed, it will use the {@link WaitForElementOptions.parent} element as the parent selector.\r\n     * \r\n     * This option will limit the scope of the query selector from the {@link WaitForElementOptions.parent} element. This may be useful for optimizing performance.\r\n     */\r\n    parent?: ParentNode;\r\n    /**\r\n     * If set with {@link AbortSignal} instance, user will able to abort this operation by using {@link AbortSignal.abort}.\r\n     */\r\n    abortSignal?: AbortSignal;\r\n    /**\r\n     * If set to true, this operation will query select multiple element by using {@link ParentNode.querySelectorAll} instead of {@link ParentNode.querySelector}.\r\n     */\r\n    multiple?: boolean;\r\n    /**\r\n     * Enable timeout for waiting operation.\r\n     * \r\n     * If waiting operation reaches timeout, it will throw {@link WaitForElementTimeoutError} or return null, depending on {@link WaitForElementOptions.throwError} option.\r\n     * \r\n     * The timeout is set by {@link WaitForElementOptions.timeout} option. The timeout is set in millisecond.\r\n     */\r\n    enableTimeout?: boolean;\r\n    /**\r\n     * Set the timeout in millisecond. Default timeout is 5 seconds.\r\n     * \r\n     * This option will do nothing if {@link WaitForElementOptions.enableTimeout} is set to false.\r\n     * @see {@link WaitForElementOptions.enableTimeout}\r\n     */\r\n    timeout?: number;\r\n    /**\r\n     * Set how many attempt this operation can query select the target element.\r\n     * \r\n     * If it reaches max attempt, it will throw {@link WaitForElementMaximumTriesError} or return null, depending on {@link WaitForElementOptions.throwError} option.\r\n     */\r\n    maxTries?: number;\r\n    /**\r\n     * Ensure DOM content loaded by listening to `DOMContentLoad` event, or checking {@link document.readyState} before running this operation.\r\n     */\r\n    ensureDomContentLoaded?: boolean;\r\n    /** \r\n     * Set options for {@link MutationObserver} used in this operation.\r\n     */\r\n    observerOptions?: MutationObserverInit;\r\n    /**\r\n     * Filter the target element(s) before being returned.\r\n     */\r\n    filter?: (elem: Element | null) => boolean;\r\n    /** \r\n     * Transform the target element(s) before being returned.\r\n     */\r\n    transform?: (elem: Element | null) => Element;\r\n}\r\n\r\nexport type WaitForElementReturnType = HTMLElement | HTMLElement[] | null;\r\n\r\n/**\r\n * Wait and get element that is not yet available in DOM by using element's ID asyncronously. It will use {@link document.getElementById} internally for getting the element.\r\n * \r\n * This is a simple wrapper around {@link waitForElementByOptions}.\r\n * @param id specify element's ID value\r\n * @param options specify additional options for {@link waitForElementByOptions}\r\n * @returns element with specified ID or null if element not found or something went wrong\r\n * @see {@link WaitForElementOptions}\r\n * @see {@link waitForElementByOptions}\r\n */\r\nexport function waitForElementById(id: string): Promise<Element | null> {\r\n    return waitForElementByOptions({ id })\r\n}\r\n\r\n/**\r\n * Wait for element that is not available yet in the DOM asyncronously, then return that element.\r\n * \r\n * Instead of query selecting element through {@link document.documentElement}, it will instead use the parent element specified by the `parent` parameter as the scope for query selection.\r\n * \r\n * This may help optimize performance, searching element through specific scope of another element instead of the entire document.\r\n * \r\n * This is a simple wrapper around {@link waitForElementByOptions}.\r\n * @param parent specify scope for target element query selection by parent element\r\n * @param selector specify selector for the target element\r\n * @param options specify additional options for {@link waitForElementByOptions}\r\n * @returns return multiple elements in {@link Array}, a single element or null depending on the parameters\r\n * @see {@link WaitForElementOptions}\r\n * @see {@link waitForElementByOptions}\r\n */\r\nexport function waitForElementByParent<S extends keyof HTMLElementTagNameMap>(parent: ParentNode, selector: S, options?: WaitForElementOptions & { multiple: false }): Promise<HTMLElementTagNameMap[S] | null>;\r\nexport function waitForElementByParent(parent: ParentNode, selector: string, options?: WaitForElementOptions & ({ multiple: false } | { id: string })): Promise<HTMLElement | null>;\r\nexport function waitForElementByParent(parent: ParentNode, selector: string, options?: WaitForElementOptions & { multiple: true }): Promise<HTMLElement[] | null>;\r\nexport function waitForElementByParent(parent: ParentNode, selector: string[], options?: WaitForElementOptions): Promise<HTMLElement[] | null>;\r\nexport function waitForElementByParent(parent: any, selector: any, options: any = {}): any {\r\n    return waitForElementByOptions({ selector, parent, ...options });\r\n}\r\n\r\n/**\r\n * Wait for element that is not available yet in the DOM asyncronously, then return that element.\r\n * \r\n * This is a simple wrapper around {@link waitForElementByOptions}.\r\n * @param selector specify selector for the target element\r\n * @param options specify additional options for {@link waitForElementByOptions}\r\n * @returns return multiple elements in {@link Array}, a single element or null depending on the parameters\r\n * @see {@link WaitForElementOptions}\r\n * @see {@link waitForElementByOptions}\r\n */\r\nexport function waitForElement<S extends keyof HTMLElementTagNameMap>(selector: S, options?: WaitForElementOptions & { multiple: false }): HTMLElementTagNameMap[S] | null;\r\nexport function waitForElement(selector: string, options?: WaitForElementOptions & ({ multiple: false } | { id: string })): Promise<Element | null>;\r\nexport function waitForElement(selector: string, options?: WaitForElementOptions & { multiple: true }): Promise<Element[] | null>;\r\nexport function waitForElement(selector: string[], options?: WaitForElementOptions): Promise<Element[] | null>;\r\nexport function waitForElement(selector: any, options: any = {}): any {\r\n    return waitForElementByOptions({ selector, ...options });\r\n}\r\n\r\n/**\r\n * Wait for element that is not available yet in the DOM asyncronously, then return that element.\r\n * \r\n * This operation works by listening for DOM (or an parent element specified by {@link WaitForElementOptions.parent}) subtree changes using {@link MutationObserver}, then execute element selection each time changes happen.\r\n * \r\n * If an element not found, then it will attempt to retry the same operation again. This can be controlled by using {@link WaitForElementOptions.maxTries}, {@link WaitForElementOptions.timeout}, and etc.\r\n * \r\n * Behavior described here may not be accurate if options are specifically configured.\r\n * \r\n * @param options configure how the operation works by specifying options\r\n * @returns depending on the options, it may return multiple elements in {@link Array}, a single element, or null if element not found or something went wrong\r\n * @see {@link WaitForElementOptions}\r\n * @see {@link waitForElement}\r\n */\r\nexport function waitForElementByOptions<S extends keyof HTMLElementTagNameMap>(options: WaitForElementOptions & { selector: S; multiple: false }): Promise<HTMLElementTagNameMap[S] | null>;\r\nexport function waitForElementByOptions(options: WaitForElementOptions & ({ multiple: false } | { id: string })): Promise<Element | null>;\r\nexport function waitForElementByOptions(options: WaitForElementOptions & { multiple: true }): Promise<Element[] | null>;\r\nexport function waitForElementByOptions(options: WaitForElementOptions & { selector: string[] }): Promise<Element[] | null>;\r\nexport function waitForElementByOptions(\r\n    { id,\r\n        selector,\r\n        parent = document.documentElement,\r\n        abortSignal,\r\n        multiple = false,\r\n        timeout = 5000,\r\n        enableTimeout = true,\r\n        maxTries = Number.MAX_SAFE_INTEGER,\r\n        ensureDomContentLoaded = true,\r\n        observerOptions = {},\r\n        filter,\r\n        transform }: WaitForElementOptions = {}) {\r\n    return new Promise((resolve, reject) => {\r\n        let result: Element | Element[] | null,\r\n            tries = 0;\r\n\r\n        if (ensureDomContentLoaded && document.readyState == \"loading\") {\r\n            document.addEventListener(\"DOMContentLoaded\", () => {\r\n                initQueryElement();\r\n            });\r\n        }\r\n        else {\r\n            initQueryElement();\r\n        }\r\n\r\n        function initQueryElement() {\r\n            const firstResult = processQueryElement();\r\n\r\n            if (firstResult) return;\r\n            \r\n            let observer = makeMutationObserver(\r\n                { target: parent,\r\n                    childList: true,\r\n                    subtree: true,\r\n                    abortSignal,\r\n                    ...observerOptions },\r\n                () => processQueryElement(observer));\r\n    \r\n            let timeoutId = -1;\r\n    \r\n            if (enableTimeout) {\r\n                timeoutId = window.setTimeout(() => {\r\n                    observer.disconnect();\r\n                    resolve(null);\r\n                }, timeout);\r\n            }\r\n    \r\n            abortSignal?.addEventListener(\"abort\", () => {\r\n                clearTimeout(timeoutId);\r\n                observer.disconnect();\r\n                resolve(null);\r\n            });\r\n    \r\n            processQueryElement();\r\n        }\r\n\r\n        function processQueryElement(observer?: MutationObserver) {\r\n            abortSignal?.throwIfAborted();\r\n\r\n            if (multiple && selector != undefined && id == undefined) {\r\n                if (Array.isArray(selector)) {\r\n                    result = [];\r\n                    for (const sel of selector) {\r\n                        result = result.concat(Array.from(parent.querySelectorAll(sel)));\r\n                    }\r\n                }\r\n                else {\r\n                    result = Array.from(applyFilterTransform(parent.querySelectorAll(selector)));\r\n                }\r\n            }\r\n            else {\r\n                if (id) {\r\n                    result = document.getElementById(id);\r\n                }\r\n                else if (Array.isArray(selector)) {\r\n                    result = [];\r\n\r\n                    result = Array.from(applyFilterTransform(parent.querySelectorAll(selector.join(\", \"))));\r\n                }\r\n                else if (typeof selector == \"string\") {\r\n                    result = parent.querySelector(selector);\r\n\r\n                    if (transform) result = transform(result);\r\n                    if (filter != undefined && !filter(result)) {\r\n                        return null;\r\n                    }\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n\r\n            function* applyFilterTransform(elements: Iterable<Element>) {\r\n                for (let elem of elements) {\r\n                    if (filter != null && filter(elem)) {\r\n                        if (transform) elem = transform(elem);\r\n                        yield elem;\r\n                    }\r\n                    else if (filter == null && transform) {\r\n                        yield transform(elem);\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n            if (multiple && Array.isArray(result) ? result.length > 0 : result) {\r\n                observer?.disconnect();\r\n                resolve(result);\r\n                return result;\r\n            }\r\n\r\n            tries++;\r\n\r\n            if (tries >= maxTries) {\r\n                observer?.disconnect();                \r\n                resolve(null);\r\n                return null;\r\n            }\r\n        }\r\n    });\r\n}"],"names":["makeMutationObserver","target","abortSignal","once","options","callback","observer","records","waitForElementById","id","waitForElementByOptions","waitForElementByParent","parent","selector","waitForElement","multiple","timeout","enableTimeout","maxTries","ensureDomContentLoaded","observerOptions","filter","transform","resolve","reject","result","tries","initQueryElement","processQueryElement","timeoutId","sel","applyFilterTransform","elements","elem"],"mappings":"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"}